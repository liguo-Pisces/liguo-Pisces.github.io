#+TITLE: Go基础
#+AUTHOR: LiGuo

* TODO 简介

Go是Google开发的一种静态强类型、编译行、并发行，并具有垃圾回收功能的编程语言。


* 程序结构
  
** 名称
   
Go中函数、变量、常量、类型、语句标签和包的名称遵循一个简单的规则：名称的开头是一个字母（Unicode中的字符即可）或下划线，后面可以跟任意数量的字符、数字和下划线，并区分大小写。

Go的关键字，只能用在语法允许的地方，它们不能作为名称：

| break    | default     | func   | interface | select |
| case     | defer       | go     | map       | struct |
| chan     | else        | goto   | package   | switch |
| const    | fallthrough | if     | range     | type   |
| continue | for         | import | return    | var    |

另外，还有一些内置的的预声明的常量、类型和函数：

| 常量： | true    | false   | iota      | nil        |        |         |       |        |
| 类型： | int     | int8    | int16     | int32      | int64  |         |       |        |
|        | uint    | uint8   | uint16    | uint32     | uint64 | uintptr |       |        |
|        | float32 | float64 | complex64 | complex128 |        |         |       |        |
|        | bool    | byte    | rune      | string     | error  |         |       |        |
| 函数： | make    | len     | cap       | new        | append | copy    | close | delete |
|        | complex | real    | imag      |            |        |         |       |        |
|        | panic   | recover    |           |            |        |         |       |        |

这些名称不是预留的，可以在声明中使用它们。我们将在很多地方看到对其中的名称进行重声明，但是要知道这有冲突的风险。

如果一个实体在函数中声明，它只在函数局部有效。如果声明在函数外，它将对包里面的所有源文件可见。实体第一个字母的大小写决定其可见行是否跨包。如果名称以大写字母的开头，它是导出的，意味着它对包外是可见和可访问的，可以被自己包之外的其他程序所引用。包名本身总是由小写字母组成。

名称本身没有长度限制，但是习惯以及Go的编程风格倾向于使用短名称，特别是作用域较小的局部变量。通常，名称的作用域越大，就使用越长且更有意义的名称。

风格上，当遇到由单词组合的名称时，Go程序员使用“驼峰法”的风格 -- 更喜欢使用大写字母而不是下划线。像ASCII和HTML这样的首字母缩写词通常使用相同的大小写。


** 声明

声明给一个程序实体命名，并且设定其部分或全部属性。有4个主要的声明：变量（var）、常量（const）、类型（type）和函数（func）。

Go程序存储在一个或多个以.go为后缀的文件里。每一个文件以package声明开头，表明文件属于哪个包。package声明后面是import声明，然后是包级别的类型、变量、常量、函数的声明，不区分顺序。


** 变量

var声明创建一个具体类型的变量，然后给它附加一个名字，设置它的初始值。每一个声明有一个通用的形式：var name type = expression

类型和表达式部分可以省略一个，但是不能都省略。如果类型省略，它的类型将由初始化表达式决定；如果表达式省略，其初始值对应于类型的零值 -- 对于数字是0，对于布尔值是false，对于字符串是""，对于接口和引用类型（slice、指针、map、通道、函数）是nil。对于一个像数组或结构体这样的复合类型，零值是其所有元素或成员的零值。

零值机制保障所有的变量是良好定义的，Go里面不存在未初始化变量。这种机制简化了代码，并且不需要额外工作就能感知边界条件的行为。Go程序员经常花费精力来使复杂类型的零值有意义，以便变量一开始就处于一个可用状态。

可以声明一个变量列表，并选择使用对应的表达式列表对其初始化。忽略类型允许声明多个不同类型的变量。

初始值设定可以是字面量值或者任意的表达式。包级别的初始化在main开始之前进行，局部变量初始化和声明一样在函数执行期间进行。

变量可以通过调用返回多个值的函数进行初始化。

*** 短变量声明

在函数中，一种称作短变量声明的可选形式可以用来声明和初始化局部变量。它使用name := expression的形式，name的类型由expression的类型决定。

因其短小、灵活，故而在局部变量的声明和初始化中主要使用短声明。var声明通常是为那些跟初始化表达式不一致的局部变量保留的，或者用于后面才对变量赋值以及变量初始值不重要的情况。

:=表示声明，而=表示赋值。

一个容易被忽略但重要的地方是：短变量声明不需要声明所有在左边的变量。如果一些变量在同一个词法块中声明，那么对于那些变量，短声明的行为等同于赋值。

只有在同一个词法块中已经存在的变量的情况下，短声明的行为才和赋值操作一样，外层的声明将被忽略。


*** 指针

变量是存储值的地方。借助声明创建的变量使用名字来区分。所有这些表达式读取一个变量的值，除非它们出现在赋值操作符的左边，这个时候是给变量赋值。

指针的值是一个变量的地址。一个指针指示值所保存的位置。不是所有的值都有地址，但是所有的变量都有。使用指针，可以在无须知道变量名字的情况下，间接读取或更新变量的值。

每一个聚合类型变量的组成（结构体的成员或数组中的元素）都是变量，所以也有一个地址。

变量有时候使用一个地址化的值。代表变量的表达式，是唯一可以应用取地址操作符&的表达式。

指针类型的零值是nil。测试p!=nil，结果是true说明p指向一个变量。指针是可比较的，两个指针当且仅当指向同一个变量或者两者都是nil的情况下才相等。

函数返回局部变量的地址是非常安全的。

因为一个指针包含变量的地址，所以传递一个指针参数给函数，能够让函数更新间接传递的变量值。

每次使用变量的地址或者复制一个指针，我们就创建了新的别名或者方式来标记同一变量。指针别名允许我们不用变量的名字来访问变量，这一点是非常有用的，但是它是双刃剑：为了找到所有访问变量的语句，需要知道所有的别名。不仅指针产生别名，当复制其他引用类型（像slice、map、通道，甚至包含这里引用类型的结构体、数组和接口）的值的时候，也会产生别名。

*** new函数



* 基本数据类型
  
** 整数
   
Go同时具备有符号整数和无符号整数。有符号整数分四种大小：8位、16位、32位、64位，用int8、int16、int32、int64表示，对应的无符号整数是uint8、uint16、uint32、uint64。

此外还有两种类型int和uint。int是目前使用最广泛的数值类型。这两种类型大小相等，都是32位或64位，但不能认为它们一定就是32位，或一定就是64位；即使在相同的硬件平台上，不同的编译器可能选用不同的大小。

rune类型是int32类型的同义词，常常用于指明一个值的Unicode码点（code point）。同样，byte类型是uint8类型的同义词，强调一个值是原始数据，而非量值。

最后，还有一种无符号整数uintptr，其大小并不明确，但足以完整存放指针。uintptr类型仅仅用于底层编程。

int、uint和uintptr都有别于其大小明确的相似类型的类型。

有符号整数以补码表示，保留最高位作为符号位，n位数字的取值范围是-2^(n-1)~2^(n-1)-1。无符号整数由全部位构成其非负值，范围是0~x^n-1。


** 浮点数 
  
Go具有两种大小的浮点数float32和float64。其算术特性遵从IEEE 754标准，所有新式CPU都支持该标准。

这两个类型的值可从极细微到超宏大。

十进制下，float32的有效数字大约是6位，float64的有效数字大约是15位。绝大多数情况下，应优先选用float64，因为除非格外小心，否则float32的运算会迅速累积误差。

在源码中，浮点数可写成小数，小数点前的数字可以省略（.707），后面的也可省去（1.）。非常小或非常大的数字最好使用科学计数法表示，此方法在数量级指数前写字母e或E。



** 复数
   
** 布尔值
   
** 字符串

** 常量


* 复合数据类型
  
** 数组

** slice

** map

** 结构体
   
* 函数

* 方法

* 接口

* goroutine和通道
