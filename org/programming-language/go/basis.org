#+TITLE: Go基础
#+AUTHOR: LiGuo
#+OPTIONS: toc:nil num:3 H:4 ^:nil pri:t
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css" />

* TODO 简介

Go是Google开发的一种静态强类型、编译行、并发行，并具有垃圾回收功能的编程语言。


* 程序结构
  
** 名称
   
Go中函数、变量、常量、类型、语句标签和包的名称遵循一个简单的规则：名称的开头是一个字母（Unicode中的字符即可）或下划线，后面可以跟任意数量的字符、数字和下划线，并区分大小写。

Go的关键字，只能用在语法允许的地方，它们不能作为名称：

| break    | default     | func   | interface | select |
| case     | defer       | go     | map       | struct |
| chan     | else        | goto   | package   | switch |
| const    | fallthrough | if     | range     | type   |
| continue | for         | import | return    | var    |

另外，还有一些内置的的预声明的常量、类型和函数：

| 常量： | true    | false   | iota      | nil        |        |         |       |        |
| 类型： | int     | int8    | int16     | int32      | int64  |         |       |        |
|        | uint    | uint8   | uint16    | uint32     | uint64 | uintptr |       |        |
|        | float32 | float64 | complex64 | complex128 |        |         |       |        |
|        | bool    | byte    | rune      | string     | error  |         |       |        |
| 函数： | make    | len     | cap       | new        | append | copy    | close | delete |
|        | complex | real    | imag      |            |        |         |       |        |
|        | panic   | recover    |           |            |        |         |       |        |

这些名称不是预留的，可以在声明中使用它们。我们将在很多地方看到对其中的名称进行重声明，但是要知道这有冲突的风险。

如果一个实体在函数中声明，它只在函数局部有效。如果声明在函数外，它将对包里面的所有源文件可见。实体第一个字母的大小写决定其可见行是否跨包。如果名称以大写字母的开头，它是导出的，意味着它对包外是可见和可访问的，可以被自己包之外的其他程序所引用。包名本身总是由小写字母组成。

名称本身没有长度限制，但是习惯以及Go的编程风格倾向于使用短名称，特别是作用域较小的局部变量。通常，名称的作用域越大，就使用越长且更有意义的名称。

风格上，当遇到由单词组合的名称时，Go程序员使用“驼峰法”的风格 -- 更喜欢使用大写字母而不是下划线。像ASCII和HTML这样的首字母缩写词通常使用相同的大小写。


** 声明

声明给一个程序实体命名，并且设定其部分或全部属性。有4个主要的声明：变量（var）、常量（const）、类型（type）和函数（func）。

Go程序存储在一个或多个以.go为后缀的文件里。每一个文件以package声明开头，表明文件属于哪个包。package声明后面是import声明，然后是包级别的类型、变量、常量、函数的声明，不区分顺序。


** 变量

var声明创建一个具体类型的变量，然后给它附加一个名字，设置它的初始值。每一个声明有一个通用的形式：var name type = expression

类型和表达式部分可以省略一个，但是不能都省略。如果类型省略，它的类型将由初始化表达式决定；如果表达式省略，其初始值对应于类型的零值 -- 对于数字是0，对于布尔值是false，对于字符串是""，对于接口和引用类型（slice、指针、map、通道、函数）是nil。对于一个像数组或结构体这样的复合类型，零值是其所有元素或成员的零值。

零值机制保障所有的变量是良好定义的，Go里面不存在未初始化变量。这种机制简化了代码，并且不需要额外工作就能感知边界条件的行为。Go程序员经常花费精力来使复杂类型的零值有意义，以便变量一开始就处于一个可用状态。

可以声明一个变量列表，并选择使用对应的表达式列表对其初始化。忽略类型允许声明多个不同类型的变量。

初始值设定可以是字面量值或者任意的表达式。包级别的初始化在main开始之前进行，局部变量初始化和声明一样在函数执行期间进行。

变量可以通过调用返回多个值的函数进行初始化。

*** 短变量声明

在函数中，一种称作短变量声明的可选形式可以用来声明和初始化局部变量。它使用name := expression的形式，name的类型由expression的类型决定。

因其短小、灵活，故而在局部变量的声明和初始化中主要使用短声明。var声明通常是为那些跟初始化表达式不一致的局部变量保留的，或者用于后面才对变量赋值以及变量初始值不重要的情况。

:=表示声明，而=表示赋值。

一个容易被忽略但重要的地方是：短变量声明不需要声明所有在左边的变量。如果一些变量在同一个词法块中声明，那么对于那些变量，短声明的行为等同于赋值。

只有在同一个词法块中已经存在的变量的情况下，短声明的行为才和赋值操作一样，外层的声明将被忽略。


*** 指针

变量是存储值的地方。借助声明创建的变量使用名字来区分。所有这些表达式读取一个变量的值，除非它们出现在赋值操作符的左边，这个时候是给变量赋值。

指针的值是一个变量的地址。一个指针指示值所保存的位置。不是所有的值都有地址，但是所有的变量都有。使用指针，可以在无须知道变量名字的情况下，间接读取或更新变量的值。

每一个聚合类型变量的组成（结构体的成员或数组中的元素）都是变量，所以也有一个地址。

变量有时候使用一个地址化的值。代表变量的表达式，是唯一可以应用取地址操作符&的表达式。

指针类型的零值是nil。测试p!=nil，结果是true说明p指向一个变量。指针是可比较的，两个指针当且仅当指向同一个变量或者两者都是nil的情况下才相等。

函数返回局部变量的地址是非常安全的。

因为一个指针包含变量的地址，所以传递一个指针参数给函数，能够让函数更新间接传递的变量值。

每次使用变量的地址或者复制一个指针，我们就创建了新的别名或者方式来标记同一变量。指针别名允许我们不用变量的名字来访问变量，这一点是非常有用的，但是它是双刃剑：为了找到所有访问变量的语句，需要知道所有的别名。不仅指针产生别名，当复制其他引用类型（像slice、map、通道，甚至包含这里引用类型的结构体、数组和接口）的值的时候，也会产生别名。


*** new函数

另外一种创建变量的方式是使用内置的new函数。表达式new(T)创建一个未命名的T类型变量，初始化为T类型的零值，并返回其地址（地址类型为*T）。

使用new创建的变量和取值地址的普通局部变量没有什么不同，只是不需要引入（和声明）一个虚拟的名字，通过new(T)就可以直接在表达式中使用。因此new只是语法上的便利，不是一个基础概念。

每一次调用new返回一个具有唯一地址的不同变量。这个规则有一个例外：两个变量的类型不携带任何信息且是零值，例如struct{}或[0]int，当前的实现里面，它们有相同的地址。


*** 变量的生命周期

生命周期指在程序执行过程中变量存在的时间段。包级别变量的生命周期是整个程序的执行时间。相反，局部变量有一个动态的生命周期：每次执行声明语句时创建一个新的实体，变量一直生存到它变得不可访问，这时它占用的存储空间被回收。函数的参数和返回值也是局部变量，它们是在其闭包函数被调用的时候创建。

那么垃圾回收器如何知道一个变量是否应该被回收？说来话长，基本思路是每一个包级别的变量，以及每一个当前执行函数的局部变量，可以作为追溯该变量的路径的源头，通过指针和其他方式的引用可以找到变量。如果变量的路径不存在，那么变量变得不可访问，因此它不会影响任何其他的计算过程。

因此变量的生命周期是通过它是否可达来确定的，所以局部变量可在包含它的循环的一次迭代之外继续存活。即使包含它的循环已经返回，它的存在还可能延续。

编译器可以选择使用堆或栈上的空间来分配，令人惊奇的是，这个选择不是基于使用var或new关键字来声明变量。

垃圾回收对于写出正确的程序有巨大的帮助，但是免不了考虑内存的负担。不需要显式分配和释放内存，但是变量的生命周期是写出高效程序所必须清楚的。例如：在长生命周期对象中保持短生命周期对象不必要的指针，特别是在全局变量中，会阻止垃圾回收器回收短生命周期的对象空间。


** 赋值

赋值语句用来更新变量所指的值，它最简单的形式由赋值符=，以及符号左边的变量和右边的表达式组成。

每一个算术和二进制位操作符有一个对应的赋值操作符。

数字变量也可以通过++和--语句进行递增和递减。

*** 多重赋值

另一种形式的赋值是多重赋值，它允许几个变量一次性被赋值。在实际更新变量前，右边所有的表达式被推演，当变量同时出现在赋值符两侧的时候这种形式特别有用。

多重赋值也可以使用一个普通的赋值序列变得紧凑。从风格上考虑，如果表达式比较复杂，则避免使用多重赋值形式；一系列独立的语句更易读。

这类表达式（例如一个有多个返回值的函数条用）产生多个值。当在一个赋值语句中使用这样的调用时，左边的变量个数需要和函数的返回值一样多。

*** 可赋值性

赋值语句是显式形式的赋值，但是程序中很多地方的赋值是隐式的：一个函数调用隐式地将参数的值赋给对应参数的变量；一个return语句隐式地将return操作数赋值给结果变量。复合类型的字面量表达式。

map和通道的元素尽管不是普通变量，但它们也遵循相似的隐式赋值。

不管隐式还是显式赋值，如果左边的（变量）和右边的（值）类型相同，它就是合法的。通俗地说，赋值只有在值对于变量类型是可赋值的时才合法。

可赋值性根据类型不同有着不同的规则，我们将会在引入新类型的时候解释相应的规则。对已经讨论过的类型，规则很简单：类型必须进准匹配，nil可以被赋给任何接口变量或引用类型。常量有更灵活的可赋值性规则来规避显式的转换。

两个值使用==和!=进行比较于赋值性相关：任何比较中，第一个操作数相对于第二个操作数的类型必须是可赋值的，或者可以反过来赋值。与可赋值性一样，我们也将解释新类型的可比较性的相关规则。


** 类型声明

变量或表达式的类型定义这些值应有的特性，例如大小（多少位或多少个元素等）、在内部如何表达、可以对其进行何种操作以及它们所有关联的方法。

任何程序中，都有一些变量使用相同的表达方式，但是含义相差非常大。例如，int类型可以用于表示循环索引、时间戳、文件描述符或月份；float64类型可以表示每秒多少米的速度或精确到几位小数的温度；string类型可以表示密码或者颜色的名字。

type声明定义一个新的命名类型，它和某个已有类型使用同样的底层类型。命名类型提供了一种方式来区分底层类型的不同或者不兼容使用，这样它们就不会在无意中混用。

type name underlying-type

类型的声明通常出现在包级别，这里命名的类型在整个包中可见，如果名字是导出的（开头使用大写字母），其他的包也可以访问它。

对于每个类型T，都有一个对应的类型转换操作T(x)将值x转换为类型T。如果两个类型具有相同的底层类型或两者都是指向相同底层类型变量的未命名指针类型，则两者是可以相互转换的。类型转换不改边类型值的表达方式，仅改变类型。如果x对于类型T是可赋值的，类型转换也是允许的，但是通常是不必要的。

数字类型间的转换，字符串和一些slice类型间的转换是允许的。这些转换会改变值的表达方式。

命名类型的底层类型决定了它的结构和表达方式，以及它支持的内部操作集合，这些内部操作与直接使用底层类型的情况相同。

命名类型的值可以与其他相同类型的值或底层类型相同的未命名类型的值相比较。但是不同命名类型的值不能直接比较。


** TODO 包和文件

在Go语言中包的作用和其他语言中的库或模块的作用，用于支持模块化、封装、编译隔离和重用。一个包的源代码保存在一个或多个以.go结尾的文件中，它所在的目录名的尾部就是包的导入路径。

每一个包给它的声明提供独立的命名空间。

包让我们可以通过控制变量在包外面的可见性或导出情况来隐藏信息。在Go里，通过一条简单的规则来管理标识符是否对外可见：导出的标识符以大写字母开头。

每一个文件的开头用package声明定义包的名称。如果包级别的名称（像类型和常量）在包的一个文件中声明，就像所有的源代码在同一个文件中一样，它们对于同一个包的其他文件可见。

package声明前面紧挨着的文档注释对整个包进行描述。习惯上，应该在开头用一句话对包进行总结性的描述。每一个包里只有一个文件应该包含该包的文档注释。扩展的文档注释通常放在一个文件中，按惯例名字叫作doc.go。

*** 导入

在Go程序里，每一个包通过称为导入路径（import path）的唯一字符串来标识。除了导入路径之外，每个包还有一个包名，它以短名字的形式（且不必是唯一的）出现在包的声明中。按约定，包名匹配导入路径的最后一段。

导入声明可以给导入的包绑定一个短名字，用来在整个文件中引用包的内容。

如果导入一个没有被引用的包，就会出发一个错误。


*** 包初始化

包的初始化从初始化包级别的变量开始，这些变量按照声明顺序初始化，在依赖已解析完毕的情况下，根据依赖的顺序进行。

如果包由多个.go文件组成，初始化按照编译器收到文件的顺序进行：go工具会在调用编译器前将.go文件进行排序。

对于包级别的每一个变量，声明周期从其值被初始化开始，但是对于其他一些变量，比如数据表，初始化表达式不是简单地设置它的初始化值。这种情况下，init函数的机制会比较简单。任何文件可以包含任意数量的声明如下的函数：

func init() { ... }

这个init函数不能被调用和被引用，另一方面，它也是普通的函数。在每一个文件里，当程序启动的时候，init函数按照它们声明的顺序自动执行。

包初始化按照在程序中导入的顺序来进行，依赖顺序优先，每次初始化一个包。初始化过程是自下向上的，main包最后初始化。在这种方式下，在程序的main函数开始执行前，所有的包已初始化完毕。


*** 作用域

声明将名字和程序实体关联起来，如一个函数或一个变量。声明的作用域是指用到声明时所声明名字的源代码段。

不要将作用域和生命周期混淆。声明的作用域是声明在程序文本中出现的区域，它是一个编译时属性。变量的生命周期是变量在程序执行期间能被程序的其他部分所引用的起止时间，它是一个运行时属性。

语法块（block）是由大括号围起来的一个语句序列，比如一个循环体或函数体。在语法块内部声明的变量对块外部不可见。块把声明包围起来，并且决定了它的可见性。我们可以把块的概念推广到其他没有显式包含在大括号中的声明代码，将其统称为词法块。包含了全部源代码的词法块，叫做全局块。每一个包，每一个文件，每一个for、if和switch语句，以及switch和select语句中的每一个条件，都是写在一个词法块里的。当然，显式写的大括号语法里的代码块也算是一个词法块。

一个声明的词法块决定声明的作用域大小。

控制流标签（如break、continue和goto语句使用的标签）的作用域是整个外层的函数。

一个程序可以包含多个同名的声明，前提是它们在不同词法块中。然而，不要滥用，重声明所涉及的作用域越广，越可能 影响其他的代码。

当编译器遇到一个名字的引用时，将从最内层的封闭词法块到全局块寻找其声明。如果没有找到，它会报“undeclared name”错误；如果在内层和外层都存在这个声明，内层的将被先找到。这种情况下，内层的声明将覆盖外部声明，使它不可访问。

不是所有的词法块都对应域显式大括号包围的语句序列，有一些词法块是隐式的。

for循环创建了两个词法块：一个是循环体本身的显式块，以及一个隐式块，它包含了一个闭合结构，其中就有初始化语句中声明的变量。隐式块中声明的变量的作用于包括条件、后置语句，以及for语句本身。

switch语句：条件对应一个块，每个case语句体对应一个块。

在包级别，声明的顺序和它们的作用域没有关系，所以一个声明可以引用它自己或者跟在它后面的其他声明，使我们可以声明递归或相互递归的类型和函数。如果常量或变量声明引用它自己，则编译器会报错。

短变量声明依赖一个明确的作用域。


* 基本数据类型
  
** 整数
   
Go同时具备有符号整数和无符号整数。有符号整数分四种大小：8位、16位、32位、64位，用int8、int16、int32、int64表示，对应的无符号整数是uint8、uint16、uint32、uint64。

此外还有两种类型int和uint。int是目前使用最广泛的数值类型。这两种类型大小相等，都是32位或64位，但不能认为它们一定就是32位，或一定就是64位；即使在相同的硬件平台上，不同的编译器可能选用不同的大小。

rune类型是int32类型的同义词，常常用于指明一个值的Unicode码点（code point）。同样，byte类型是uint8类型的同义词，强调一个值是原始数据，而非量值。

最后，还有一种无符号整数uintptr，其大小并不明确，但足以完整存放指针。uintptr类型仅仅用于底层编程。

int、uint和uintptr都有别于其大小明确的相似类型的类型。

有符号整数以补码表示，保留最高位作为符号位，n位数字的取值范围是-2^(n-1)~2^(n-1)-1。无符号整数由全部位构成其非负值，范围是0~x^n-1。


** 浮点数 
   
Go具有两种大小的浮点数float32和float64。其算术特性遵从IEEE 754标准，所有新式CPU都支持该标准。

这两个类型的值可从极细微到超宏大。

十进制下，float32的有效数字大约是6位，float64的有效数字大约是15位。绝大多数情况下，应优先选用float64，因为除非格外小心，否则float32的运算会迅速累积误差。

在源码中，浮点数可写成小数，小数点前的数字可以省略（.707），后面的也可省去（1.）。非常小或非常大的数字最好使用科学计数法表示，此方法在数量级指数前写字母e或E。

浮点值能方便地通过Printf的谓词%g输出，该谓词会自动保持足够的精度，并选择最简单的表达方式，但是对于数据表，%e（有指数）或%f（无指数）的形式可能更合适。这三个谓词都能掌控输出宽度和数值精度。

除了大量常见的数学函数之外，math包还有函数用于创建和判断IEEE 754标准定义的特殊值：正无穷大和负无穷大，它表示超出最大许可值的数及除以零的商；以及NaN（Not a Number），它表示数学上无意义的运算结果。

math.IsNAN函数判断其参数是否是非数值，math.NaN函数则返回非数值（NaN）。在数字运算中，我们倾向于将NaN当作信号值（sentinel value），但直接判断具体的计算结果是否为NaN可能导致潜在的错误，因为与NaN的比较总不成立（除了!=，它总是与==相反）。


** 复数
   
Go具备两种大小的复数complex64和complex128，两者分别由float32和float64构成。内置的complex函数根据给定的实部和虚部创建复数，而内置的real函数和imag函数则分别提取复数的实部和虚部。

源码中，如果在浮点数或十进制整数后面紧接着写字母i，它就变成一个虚数，表示一个实部为0的复数。

根据常量运算规则，复数常量可以和其他常量相加（整型或浮点型，实数和虚数皆可），这让我们可以自然地写出复数。

可以用==或!=判断复数是否等值。若两个复数的实部和虚部都相等，则它们相等。math/cmplx包提供了复数运算所需库函数。


** 布尔值
   
bool型的值或布尔值（boolean）只有两种可能：真（true）和假（false）。

布尔值可以由运算符&&（AND）以及||（OR）组合运算，这可能引起短路行为：如果运算符左边的操作数已经能直接确定总体结果，则右侧的操作数不会计算在内。

布尔值无法隐式转换成数值（如0或1），反之也不行。


** 字符串

字符串是不可变的字符序列，它可以包含任意数据，包括0值字节，但主要是人类可读的文本。习惯上，文本字符串被解读成按UTF-8编码的Unicode码点（文字符号）序列。

内置的len函数返回字符串的字节数（并非文字符号的数目），下标访问操作s[i]则取得第i个字符，其中0<=i<len(s)

试图访问许可范围以外的字节会触发宕机异常。

字符串的第i个字节不一定就是第i个字符，因为非ASCII字符的UTF-8码点需要两个字节或多个字节。

子串生成操作s[i:j]产生一个新字符串，内容取自原字符串的字节，从下标i（含边界值）开始，直到j（不含边界值）。结果的大小是j-i个字节。

操作数i与j的默认值分别是0（字符串起始位置）和len(s)（字符串终止位置），若省略i或j，或两者，则取默认值。

加号（+）运算符连接两个字符串而生成一个新字符串。

字符串可以通过比较运算符做比较，如==和<；比较运算符按字节进行，结果服从本身的字典排序。

尽管肯定可以将新值赋予字符串变量，但是字符串值无法改变：字符串值本身所包含的字节序列永不可变。

因为字符串不可改变，所以字符串内部的数据不允许修改。

不可变意味着两个字符串能安全地共用同一段底层内存，使得复制任何长度字符串的开销都低廉。

*** 字符串字面量

字符串的值可以直接写成字符串字面量（string literal），形式上就是带双引号的字符序列。

因为Go的源文件总是按UTF-8编码，并且习惯上Go的字符串会按UTF-8解读，所以在源码中我们可以将Unicode码点写入字符串字面量。

在带双引号的字符串字面量中，转义序列以反斜杠（\）开始，可以将任何值的字节插入字符串中。

源码中的字符串也可以包含十六进制或八进制的任意字节。十六进制的转义字符写成\xhh的形式，h是十六进制数字（大小写皆可），且必须是两位。八进制的转义字符写成\ooo的形式，必须使用三位八进制数字（0~7），且不能超过\377。这两者都表示单个字节，内容是给定值。

原生的字符串字面量的书写形式是`...`，使用反引号而不是双引号。原生的字符串字面量内，转义序列不起作用；实质内容与字面写法严格一致，包括反斜杠和换行符，因此，在程序源码中，原生的字符串字面量可以展开多行。唯一的特殊处理是回车符会被删除（换行符会保留），使得同一字符串在所有平台上的值都有相同，包括习惯在文本文件存入换行符的系统。

正则表达式往往含有大量反斜杠，可以方便地写成原生的字符串字面量。原生的字面量也适用于HTML模板、JSON字面量、命令行提示信息，以及需要多行文本表达的场景。

*** Unicode

Unicode（unicode.org）,它囊括了世界上所有文书体系的全部字符，还有重音符和其他变音符，控制码（如制表符和回车符），以及许多特有文字，对它们自赋予一个叫Unicode码点的标准数字。在Go的术语中，这些字符记号称为文字符号（rune）。

*** TODO UTF-8

UTF-8以字节为单位对Unicode码点作变长编码。

Go语言中，字符串字面量的转义让我们得以用码点的值来指明Unicode字符。有两种形式，\uhhhh表示16位码点值，\Uhhhhhhhh表示32位码点值，其中每个h代表一个十六进制数字；

码点值小于256的文字符号可以写成单个十六进制数转义的形式，如'A'写成'\x41'；而更高的码点值必须使用\u或\U转义。

*** 字符串和字节slice

*** 字符串和数字的相互转换


** 常量

常量是一种表达式，其可以保证在编译阶段就计算出表达式的值，并不需要等到运行时，从而使编译器得以知晓其值。所有常量本质上都属于基本类型：布尔型、字符串或数字。

常量的声明定义了具名的值，它看起来在语法上与变量类似，但该值恒定，这防止了程序运行过程中的意外（或恶意）修改。

与变量类似，同一个声明可以定义一系列常量，这适合用于一组相关的值。

许多针对常量的计算完全可以在编译时就完成，以减免运行时的工作量并让其他编译器优化得以实现。

对于常量操作数，所有数学运算、逻辑运算和比较运算的结果依然时常量，常量的类型转换结果和某些内置函数的返回值同样是常量。

常量声明可以同时指定类型和值，如果没有显式指定类型，则类型根据右边的表达式推断。

若同时声明一组常量，除了第一项之外，其他项在等号右侧的表达式都可以省略，这意味着会复用前面一项的表达式及其类型。

*** 常量生成器iota
    
常量的声明可以使用常量生成器iota，它创建一系列相关值，而不是逐个显式写出。常量声明中，iota从0开始取值，逐项加1。

*** 无类型常量

    
Go的常量自有特别之处。虽然常量可以时任何基本数据类型，如int或float64，也包括具名的基本类型（如time.Duration），但是许多常量并不从属某一具体类型。编译器将这些从属类型特定的常量表示成某些值，这些值比基本类型的数字精度更高，且算术精度高于原生的机器精度。可以认为它们的精度至少达到256位。从属类型待定的常量共有6种，分别是无类型布尔、无类型整数、无类型文字符号、无类型浮点数、无类型复数、无类型字符串。

借助推迟确定从属类型，无类型常量不仅能暂时维持更高的精度，与类型已确定的常量相比，它们还能写进更多表达式而无需转换类型。

字面量的类型由语法决定。0、0.0、0i和'\u0000'全都表示相同的常量值，但类型相异，分别是：无类型整数、无类型浮点数、无类型复数和无类型文字符号。类似地，true和false时无类型布尔值，而字符串字面量则是无类型字符串。

只有常量才可以是无类型的。若将无类型常量声明为变量或在类型明确的变量赋值的右方出现无类型常量，则常量会被隐式转换成该变量的类型。

无论隐式或显式，常量从一种类型转换成另一种，都要求目标类型能够表示原值。实数和复数允许舍入取整。

变量声明（包括短变量声明）中，加入没有显式指定类型，无类型常量会隐式转换成该变量的默认类型。

注意各类型的不对称性：无类型整数可以转换成int，其大小不确定，但无类型浮点数和无类型复数被转换成大小明确的float64和complex128。


* 复合数据类型
  
** 数组

   



** slice

** map

** 结构体
   

* 函数


* 方法


* 接口


* goroutine和通道
