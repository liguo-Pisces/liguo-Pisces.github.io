#+TITLE: Go基础
#+AUTHOR: LiGuo
#+OPTIONS: toc:nil num:3 H:4 ^:nil pri:t
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css" />

* TODO 简介

Go是Google开发的一种静态强类型、编译行、并发行，并具有垃圾回收功能的编程语言。


* 程序结构
  
** 名称
   
Go中函数、变量、常量、类型、语句标签和包的名称遵循一个简单的规则：名称的开头是一个字母（Unicode中的字符即可）或下划线，后面可以跟任意数量的字符、数字和下划线，并区分大小写。

Go的关键字，只能用在语法允许的地方，它们不能作为名称：

| break    | default     | func   | interface | select |
| case     | defer       | go     | map       | struct |
| chan     | else        | goto   | package   | switch |
| const    | fallthrough | if     | range     | type   |
| continue | for         | import | return    | var    |

另外，还有一些内置的的预声明的常量、类型和函数：

| 常量： | true    | false   | iota      | nil        |        |         |       |        |
| 类型： | int     | int8    | int16     | int32      | int64  |         |       |        |
|        | uint    | uint8   | uint16    | uint32     | uint64 | uintptr |       |        |
|        | float32 | float64 | complex64 | complex128 |        |         |       |        |
|        | bool    | byte    | rune      | string     | error  |         |       |        |
| 函数： | make    | len     | cap       | new        | append | copy    | close | delete |
|        | complex | real    | imag      |            |        |         |       |        |
|        | panic   | recover    |           |            |        |         |       |        |

这些名称不是预留的，可以在声明中使用它们。我们将在很多地方看到对其中的名称进行重声明，但是要知道这有冲突的风险。

如果一个实体在函数中声明，它只在函数局部有效。如果声明在函数外，它将对包里面的所有源文件可见。实体第一个字母的大小写决定其可见行是否跨包。如果名称以大写字母的开头，它是导出的，意味着它对包外是可见和可访问的，可以被自己包之外的其他程序所引用。包名本身总是由小写字母组成。

名称本身没有长度限制，但是习惯以及Go的编程风格倾向于使用短名称，特别是作用域较小的局部变量。通常，名称的作用域越大，就使用越长且更有意义的名称。

风格上，当遇到由单词组合的名称时，Go程序员使用“驼峰法”的风格 -- 更喜欢使用大写字母而不是下划线。像ASCII和HTML这样的首字母缩写词通常使用相同的大小写。


** 声明

声明给一个程序实体命名，并且设定其部分或全部属性。有4个主要的声明：变量（var）、常量（const）、类型（type）和函数（func）。

Go程序存储在一个或多个以.go为后缀的文件里。每一个文件以package声明开头，表明文件属于哪个包。package声明后面是import声明，然后是包级别的类型、变量、常量、函数的声明，不区分顺序。


** 变量

var声明创建一个具体类型的变量，然后给它附加一个名字，设置它的初始值。每一个声明有一个通用的形式：var name type = expression

类型和表达式部分可以省略一个，但是不能都省略。如果类型省略，它的类型将由初始化表达式决定；如果表达式省略，其初始值对应于类型的零值 -- 对于数字是0，对于布尔值是false，对于字符串是""，对于接口和引用类型（slice、指针、map、通道、函数）是nil。对于一个像数组或结构体这样的复合类型，零值是其所有元素或成员的零值。

零值机制保障所有的变量是良好定义的，Go里面不存在未初始化变量。这种机制简化了代码，并且不需要额外工作就能感知边界条件的行为。Go程序员经常花费精力来使复杂类型的零值有意义，以便变量一开始就处于一个可用状态。

可以声明一个变量列表，并选择使用对应的表达式列表对其初始化。忽略类型允许声明多个不同类型的变量。

初始值设定可以是字面量值或者任意的表达式。包级别的初始化在main开始之前进行，局部变量初始化和声明一样在函数执行期间进行。

变量可以通过调用返回多个值的函数进行初始化。

*** 短变量声明

在函数中，一种称作短变量声明的可选形式可以用来声明和初始化局部变量。它使用name := expression的形式，name的类型由expression的类型决定。

因其短小、灵活，故而在局部变量的声明和初始化中主要使用短声明。var声明通常是为那些跟初始化表达式不一致的局部变量保留的，或者用于后面才对变量赋值以及变量初始值不重要的情况。

:=表示声明，而=表示赋值。

一个容易被忽略但重要的地方是：短变量声明不需要声明所有在左边的变量。如果一些变量在同一个词法块中声明，那么对于那些变量，短声明的行为等同于赋值。

只有在同一个词法块中已经存在的变量的情况下，短声明的行为才和赋值操作一样，外层的声明将被忽略。


*** 指针

变量是存储值的地方。借助声明创建的变量使用名字来区分。所有这些表达式读取一个变量的值，除非它们出现在赋值操作符的左边，这个时候是给变量赋值。

指针的值是一个变量的地址。一个指针指示值所保存的位置。不是所有的值都有地址，但是所有的变量都有。使用指针，可以在无须知道变量名字的情况下，间接读取或更新变量的值。

每一个聚合类型变量的组成（结构体的成员或数组中的元素）都是变量，所以也有一个地址。

变量有时候使用一个地址化的值。代表变量的表达式，是唯一可以应用取地址操作符&的表达式。

指针类型的零值是nil。测试p!=nil，结果是true说明p指向一个变量。指针是可比较的，两个指针当且仅当指向同一个变量或者两者都是nil的情况下才相等。

函数返回局部变量的地址是非常安全的。

因为一个指针包含变量的地址，所以传递一个指针参数给函数，能够让函数更新间接传递的变量值。

每次使用变量的地址或者复制一个指针，我们就创建了新的别名或者方式来标记同一变量。指针别名允许我们不用变量的名字来访问变量，这一点是非常有用的，但是它是双刃剑：为了找到所有访问变量的语句，需要知道所有的别名。不仅指针产生别名，当复制其他引用类型（像slice、map、通道，甚至包含这里引用类型的结构体、数组和接口）的值的时候，也会产生别名。


*** new函数

另外一种创建变量的方式是使用内置的new函数。表达式new(T)创建一个未命名的T类型变量，初始化为T类型的零值，并返回其地址（地址类型为*T）。

使用new创建的变量和取值地址的普通局部变量没有什么不同，只是不需要引入（和声明）一个虚拟的名字，通过new(T)就可以直接在表达式中使用。因此new只是语法上的便利，不是一个基础概念。

每一次调用new返回一个具有唯一地址的不同变量。这个规则有一个例外：两个变量的类型不携带任何信息且是零值，例如struct{}或[0]int，当前的实现里面，它们有相同的地址。


*** 变量的生命周期

生命周期指在程序执行过程中变量存在的时间段。包级别变量的生命周期是整个程序的执行时间。相反，局部变量有一个动态的生命周期：每次执行声明语句时创建一个新的实体，变量一直生存到它变得不可访问，这时它占用的存储空间被回收。函数的参数和返回值也是局部变量，它们是在其闭包函数被调用的时候创建。

那么垃圾回收器如何知道一个变量是否应该被回收？说来话长，基本思路是每一个包级别的变量，以及每一个当前执行函数的局部变量，可以作为追溯该变量的路径的源头，通过指针和其他方式的引用可以找到变量。如果变量的路径不存在，那么变量变得不可访问，因此它不会影响任何其他的计算过程。

因此变量的生命周期是通过它是否可达来确定的，所以局部变量可在包含它的循环的一次迭代之外继续存活。即使包含它的循环已经返回，它的存在还可能延续。

编译器可以选择使用堆或栈上的空间来分配，令人惊奇的是，这个选择不是基于使用var或new关键字来声明变量。

垃圾回收对于写出正确的程序有巨大的帮助，但是免不了考虑内存的负担。不需要显式分配和释放内存，但是变量的生命周期是写出高效程序所必须清楚的。例如：在长生命周期对象中保持短生命周期对象不必要的指针，特别是在全局变量中，会阻止垃圾回收器回收短生命周期的对象空间。

** 赋值

赋值语句用来更新变量所指的值，它最简单的形式由赋值符=，以及符号左边的变量和右边的表达式组成。

每一个算术和二进制位操作符有一个对应的赋值操作符。

数字变量也可以通过++和--语句进行递增和递减。

*** 多重赋值

另一种形式的赋值是多重赋值，它允许几个变量一次性被赋值。在实际更新变量前，右边所有的表达式被推演，当变量同时出现在赋值符两侧的时候这种形式特别有用。

多重赋值也可以使用一个普通的赋值序列变得紧凑。从风格上考虑，如果表达式比较复杂，则避免使用多重赋值形式；一系列独立的语句更易读。

这类表达式（例如一个有多个返回值的函数条用）产生多个值。当在一个赋值语句中使用这样的调用时，左边的变量个数需要和函数的返回值一样多。

*** 可赋值性

赋值语句是显式形式的赋值，但是程序中很多地方的赋值是隐式的：一个函数调用隐式地将参数的值赋给对应参数的变量；一个return语句隐式地将return操作数赋值给结果变量。复合类型的字面量表达式。

map和通道的元素尽管不是普通变量，但它们也遵循相似的隐式赋值。

不管隐式还是显式赋值，如果左边的（变量）和右边的（值）类型相同，它就是合法的。通俗地说，赋值只有在值对于变量类型是可赋值的时才合法。



* 基本数据类型
  
** 整数
   
Go同时具备有符号整数和无符号整数。有符号整数分四种大小：8位、16位、32位、64位，用int8、int16、int32、int64表示，对应的无符号整数是uint8、uint16、uint32、uint64。

此外还有两种类型int和uint。int是目前使用最广泛的数值类型。这两种类型大小相等，都是32位或64位，但不能认为它们一定就是32位，或一定就是64位；即使在相同的硬件平台上，不同的编译器可能选用不同的大小。

rune类型是int32类型的同义词，常常用于指明一个值的Unicode码点（code point）。同样，byte类型是uint8类型的同义词，强调一个值是原始数据，而非量值。

最后，还有一种无符号整数uintptr，其大小并不明确，但足以完整存放指针。uintptr类型仅仅用于底层编程。

int、uint和uintptr都有别于其大小明确的相似类型的类型。

有符号整数以补码表示，保留最高位作为符号位，n位数字的取值范围是-2^(n-1)~2^(n-1)-1。无符号整数由全部位构成其非负值，范围是0~x^n-1。


** 浮点数 
  
Go具有两种大小的浮点数float32和float64。其算术特性遵从IEEE 754标准，所有新式CPU都支持该标准。

这两个类型的值可从极细微到超宏大。

十进制下，float32的有效数字大约是6位，float64的有效数字大约是15位。绝大多数情况下，应优先选用float64，因为除非格外小心，否则float32的运算会迅速累积误差。

在源码中，浮点数可写成小数，小数点前的数字可以省略（.707），后面的也可省去（1.）。非常小或非常大的数字最好使用科学计数法表示，此方法在数量级指数前写字母e或E。



** 复数
   
** 布尔值
   
** 字符串

** 常量


* 复合数据类型
  
** 数组

** slice

** map

** 结构体
   
* 函数

* 方法

* 接口

* goroutine和通道
